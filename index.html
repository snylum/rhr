<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>3D Hand Right-Hand Rule Visualization</title>
  <style>
    body {
      margin: 0;
      padding: 0;
      background: #0a0a0a;
      color: #00ff00;
      font-family: 'Courier New', monospace;
      overflow: hidden;
    }
    #container {
      display: flex;
      width: 100vw;
      height: 100vh;
    }
    .canvas-container {
      flex: 1;
      position: relative;
    }
    canvas {
      display: block;
      width: 100%;
      height: 100%;
    }
    .controls {
      position: absolute;
      top: 10px;
      left: 10px;
      font-size: 11px;
      color: #00ff00;
      background: rgba(0, 0, 0, 0.8);
      padding: 10px;
      border-radius: 5px;
      border: 1px solid #00ff00;
      z-index: 10;
    }
    .bottom-controls {
      position: absolute;
      bottom: 10px;
      left: 10px;
      font-size: 11px;
      background: rgba(0, 0, 0, 0.8);
      padding: 10px;
      border-radius: 5px;
      border: 1px solid #00ff00;
    }
    .vector-controls {
      position: absolute;
      bottom: 10px;
      right: 10px;
      font-size: 11px;
      background: rgba(0, 0, 0, 0.8);
      padding: 10px;
      border-radius: 5px;
      border: 1px solid #00ff00;
      width: 200px;
    }
    button {
      background: #003300;
      color: #00ff00;
      border: 1px solid #00ff00;
      padding: 5px 10px;
      margin: 2px;
      cursor: pointer;
      border-radius: 3px;
      font-family: 'Courier New', monospace;
      font-size: 10px;
    }
    button:hover {
      background: #005500;
    }
    h3 {
      margin: 0 0 10px 0;
      font-size: 13px;
    }
    input[type="number"] {
      width: 50px;
      background: #001100;
      color: #00ff00;
      border: 1px solid #00ff00;
      padding: 3px;
      font-family: 'Courier New', monospace;
      font-size: 10px;
      border-radius: 3px;
    }
    label {
      font-size: 10px;
      margin-right: 5px;
    }
    .input-group {
      margin: 5px 0;
    }
  </style>
</head>
<body>
  <div id="container">
    <!-- LEFT: 3D coordinate plane -->
    <div class="canvas-container">
      <div class="controls">
        <h3>XYZ COORDINATE PLANE</h3>
        Drag to rotate<br />
        Scroll to zoom
      </div>
      <div class="vector-controls">
        <h3>VECTORS</h3>
        <div class="input-group">
          <label>i:</label><input type="number" id="vec-i" value="5" step="1" />
          <label>j:</label><input type="number" id="vec-j" value="5" step="1" />
        </div>
        <div class="input-group">
          <label>k:</label><input type="number" id="vec-k" value="5" step="1" />
        </div>
        <button onclick="addVector()">Add Vector</button>
        <button onclick="clearVectors()">Clear All</button>
        <button onclick="resetPlaneView()">Reset View</button>
      </div>
      <canvas id="plane-canvas"></canvas>
    </div>

    <!-- RIGHT: 3D HAND -->
    <div class="canvas-container">
      <div class="controls">
        <h3>3D RIGHT HAND</h3>
        Drag to rotate<br />
        Scroll to zoom
      </div>
      <div class="bottom-controls">
        <h3>ROTATION MODE</h3>
        <button id="camera-mode" onclick="toggleRotationMode()" style="background: #005500;">Camera (Active)</button><br />
        <h3>HAND CONTROLS</h3>
        <button onclick="toggleThumb()">Thumb Up/Down</button><br />
        <button onclick="setFingers('fist')">Fist</button>
        <button onclick="setFingers('open')">Open Hand</button><br />
        <button onclick="setFingers('point')">Point</button>
        <button onclick="setFingers('peace')">Peace</button><br />
        <button onclick="resetHandView()">Reset View</button>
      </div>
      <canvas id="hand-canvas"></canvas>
    </div>
  </div>

  <script src="https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.160.0/examples/js/loaders/FBXLoader.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/fflate@0.8.0/umd/index.js"></script>

  <script>
    // ================== COORDINATE PLANE ==================
    const planeCanvas = document.getElementById("plane-canvas");
    const planeScene = new THREE.Scene();
    planeScene.background = new THREE.Color(0x0a0a0a);
    const planeCamera = new THREE.PerspectiveCamera(75, 1, 0.1, 1000);
    const planeRenderer = new THREE.WebGLRenderer({ canvas: planeCanvas, antialias: true });

    planeCamera.position.set(15, 15, 15);
    planeCamera.lookAt(0, 0, 0);

    const axisLength = 15;
    const axes = new THREE.AxesHelper(axisLength);
    planeScene.add(axes);

    const gridHelper = new THREE.GridHelper(30, 30, 0x004400, 0x002200);
    planeScene.add(gridHelper);

    const origin = new THREE.Mesh(new THREE.SphereGeometry(0.3, 16, 16), new THREE.MeshBasicMaterial({ color: 0xffff00 }));
    planeScene.add(origin);

    const vectorGroup = new THREE.Group();
    planeScene.add(vectorGroup);
    let vectors = [];

    function addVector() {
      const i = parseFloat(document.getElementById("vec-i").value);
      const j = parseFloat(document.getElementById("vec-j").value);
      const k = parseFloat(document.getElementById("vec-k").value);

      const dir = new THREE.Vector3(i, j, k);
      const length = dir.length();
      const arrow = new THREE.ArrowHelper(dir.normalize(), new THREE.Vector3(0, 0, 0), length, 0xff00ff, length * 0.2, length * 0.1);
      vectorGroup.add(arrow);
      vectors.push(arrow);
    }

    function clearVectors() {
      while (vectorGroup.children.length) vectorGroup.remove(vectorGroup.children[0]);
      vectors = [];
    }

    function resetPlaneView() {
      planeCamera.position.set(15, 15, 15);
      planeCamera.lookAt(0, 0, 0);
    }

    // ================== HAND SCENE ==================
    const handCanvas = document.getElementById("hand-canvas");
    const handScene = new THREE.Scene();
    handScene.background = new THREE.Color(0x0a0a0a);
    const handCamera = new THREE.PerspectiveCamera(75, 1, 0.1, 1000);
    const handRenderer = new THREE.WebGLRenderer({ canvas: handCanvas, antialias: true });
    handCamera.position.set(0, 0, 25);
    handCamera.lookAt(0, 0, 0);

    const hemiLight = new THREE.HemisphereLight(0xffffff, 0x444444, 1);
    hemiLight.position.set(0, 20, 0);
    handScene.add(hemiLight);

    const dirLight = new THREE.DirectionalLight(0xffffff, 1);
    dirLight.position.set(10, 10, 10);
    handScene.add(dirLight);

    let handModel, mixer, actions = {};
    const loader = new THREE.FBXLoader();

    // âœ… Using FBX hand model with bone structure
    // Load from local file - place your FBX file in the same directory as this HTML file
    loader.load(
      "./hand.fbx", // Change this to match your FBX filename
      (fbx) => {
        handModel = fbx;
        handModel.scale.set(0.1, 0.1, 0.1); // Adjust scale as needed
        handModel.position.set(0, -5, 0); // Adjust position as needed
        
        // Add basic material if needed
        handModel.traverse((child) => {
          if (child.isMesh) {
            child.material = new THREE.MeshPhongMaterial({ 
              color: 0xffdbac, 
              skinning: true 
            });
          }
        });
        
        handScene.add(handModel);
        
        // Setup animation mixer if FBX has animations
        if (fbx.animations && fbx.animations.length > 0) {
          mixer = new THREE.AnimationMixer(handModel);
          fbx.animations.forEach((clip) => {
            actions[clip.name] = mixer.clipAction(clip);
          });
        }
        
        console.log("Hand model loaded successfully");
        console.log("Bones found:", getBoneNames());
      },
      (progress) => {
        console.log("Loading: " + (progress.loaded / progress.total * 100) + "%");
      },
      (err) => {
        console.error("Failed to load hand model", err);
        console.log("Creating fallback hand geometry...");
        createFallbackHand();
      }
    );

    // Fallback hand creation if FBX fails to load
    function createFallbackHand() {
      const handGroup = new THREE.Group();
      
      // Palm
      const palm = new THREE.Mesh(
        new THREE.BoxGeometry(4, 5, 1),
        new THREE.MeshPhongMaterial({ color: 0xffdbac })
      );
      handGroup.add(palm);
      
      // Create fingers
      const fingers = ['thumb', 'index', 'middle', 'ring', 'pinky'];
      const fingerPositions = [
        { x: -2, y: 2, angle: 0.5 },
        { x: -1.5, y: 3, angle: 0 },
        { x: 0, y: 3.5, angle: 0 },
        { x: 1.5, y: 3, angle: 0 },
        { x: 2.5, y: 2, angle: 0 }
      ];
      
      fingers.forEach((name, i) => {
        const pos = fingerPositions[i];
        const finger = new THREE.Group();
        finger.name = name;
        
        for (let j = 0; j < 3; j++) {
          const segment = new THREE.Mesh(
            new THREE.CylinderGeometry(0.3, 0.3, 1.5, 8),
            new THREE.MeshPhongMaterial({ color: 0xffdbac })
          );
          segment.position.y = j * 1.5;
          segment.name = `${name}_${j}`;
          finger.add(segment);
        }
        
        finger.position.set(pos.x, pos.y, 0);
        finger.rotation.z = pos.angle;
        handGroup.add(finger);
      });
      
      handModel = handGroup;
      handModel.scale.set(1.5, 1.5, 1.5);
      handScene.add(handModel);
    }

    // Helper function to get bone names
    function getBoneNames() {
      const bones = [];
      if (handModel) {
        handModel.traverse((obj) => {
          if (obj.isBone) bones.push(obj.name);
        });
      }
      return bones;
    }

    let fingerStates = { thumb: 1, index: 1, middle: 1, ring: 1, pinky: 1 };

    function toggleThumb() {
      fingerStates.thumb = 1 - fingerStates.thumb;
      animateHandPose();
    }

    function setFingers(pose) {
      if (pose === "fist") fingerStates = { thumb: 0, index: 0, middle: 0, ring: 0, pinky: 0 };
      if (pose === "open") fingerStates = { thumb: 1, index: 1, middle: 1, ring: 1, pinky: 1 };
      if (pose === "point") fingerStates = { thumb: 1, index: 1, middle: 0, ring: 0, pinky: 0 };
      if (pose === "peace") fingerStates = { thumb: 0, index: 1, middle: 1, ring: 0, pinky: 0 };
      animateHandPose();
    }

    function animateHandPose() {
      if (!handModel) return;
      
      // For FBX models with proper bone structure
      handModel.traverse((bone) => {
        if (bone.isBone) {
          const name = bone.name.toLowerCase();
          
          // Thumb control
          if (name.includes("thumb")) {
            bone.rotation.z = fingerStates.thumb ? 0 : -0.8;
          }
          // Index finger control
          if (name.includes("index")) {
            bone.rotation.z = fingerStates.index ? 0 : -1.2;
          }
          // Middle finger control
          if (name.includes("middle")) {
            bone.rotation.z = fingerStates.middle ? 0 : -1.2;
          }
          // Ring finger control
          if (name.includes("ring")) {
            bone.rotation.z = fingerStates.ring ? 0 : -1.2;
          }
          // Pinky finger control
          if (name.includes("pinky") || name.includes("little")) {
            bone.rotation.z = fingerStates.pinky ? 0 : -1.2;
          }
        }
      });
      
      // For fallback geometry hand
      if (handModel && !handModel.traverse) {
        handModel.children.forEach((child) => {
          if (child.name === 'thumb') {
            child.rotation.x = fingerStates.thumb ? 0 : -0.6;
          }
          if (child.name === 'index') {
            child.rotation.x = fingerStates.index ? 0 : -0.9;
          }
          if (child.name === 'middle') {
            child.rotation.x = fingerStates.middle ? 0 : -0.9;
          }
          if (child.name === 'ring') {
            child.rotation.x = fingerStates.ring ? 0 : -0.9;
          }
          if (child.name === 'pinky') {
            child.rotation.x = fingerStates.pinky ? 0 : -0.9;
          }
        });
      }
    }

    function resetHandView() {
      handCamera.position.set(0, 0, 25);
      handCamera.lookAt(0, 0, 0);
      if (handModel) handModel.rotation.set(0, 0, 0);
    }

    // ================== CONTROLS ==================
    let planeMouseDown = false, planeMouseX = 0, planeMouseY = 0;
    planeCanvas.addEventListener("mousedown", (e) => { planeMouseDown = true; planeMouseX = e.clientX; planeMouseY = e.clientY; });
    planeCanvas.addEventListener("mousemove", (e) => {
      if (planeMouseDown) {
        const dx = e.clientX - planeMouseX, dy = e.clientY - planeMouseY;
        const axis = new THREE.Vector3(dy, dx, 0).normalize();
        const angle = Math.sqrt(dx * dx + dy * dy) * 0.01;
        planeCamera.position.applyAxisAngle(axis, angle);
        planeCamera.lookAt(0, 0, 0);
        planeMouseX = e.clientX; planeMouseY = e.clientY;
      }
    });
    planeCanvas.addEventListener("wheel", (e) => {
      e.preventDefault();
      const delta = e.deltaY * 0.01;
      const dir = planeCamera.position.clone().normalize();
      planeCamera.position.addScaledVector(dir, delta);
    });

    let handMouseDown = false, handMouseX = 0, handMouseY = 0;
    let handRotationMode = "camera";

    function toggleRotationMode() {
      handRotationMode = handRotationMode === "camera" ? "hand" : "camera";
      const btn = document.getElementById("camera-mode");
      btn.textContent = handRotationMode === "camera" ? "Camera (Active)" : "Hand (Active)";
      btn.style.background = "#005500";
    }

    handCanvas.addEventListener("mousedown", (e) => {
      handMouseDown = true;
      handMouseX = e.clientX;
      handMouseY = e.clientY;
    });

    handCanvas.addEventListener("mousemove", (e) => {
      if (handMouseDown) {
        const dx = e.clientX - handMouseX, dy = e.clientY - handMouseY;
        if (handRotationMode === "camera") {
          const axis = new THREE.Vector3(dy, dx, 0).normalize();
          const angle = Math.sqrt(dx * dx + dy * dy) * 0.01;
          handCamera.position.applyAxisAngle(axis, angle);
          handCamera.lookAt(0, 0, 0);
        } else if (handModel) {
          handModel.rotation.y += dx * 0.01;
          handModel.rotation.x += dy * 0.01;
        }
        handMouseX = e.clientX;
        handMouseY = e.clientY;
      }
    });

    handCanvas.addEventListener("wheel", (e) => {
      e.preventDefault();
      handCamera.position.z += e.deltaY * 0.01;
    });

    document.addEventListener("mouseup", () => {
      planeMouseDown = false;
      handMouseDown = false;
    });

    // ================== RENDER LOOP ==================
    function resize() {
      const width = window.innerWidth / 2, height = window.innerHeight;
      planeRenderer.setSize(width, height);
      planeCamera.aspect = width / height;
      planeCamera.updateProjectionMatrix();
      handRenderer.setSize(width, height);
      handCamera.aspect = width / height;
      handCamera.updateProjectionMatrix();
    }

    window.addEventListener("resize", resize);
    resize();

    const clock = new THREE.Clock();

    function animate() {
      requestAnimationFrame(animate);
      if (mixer) mixer.update(clock.getDelta());
      planeRenderer.render(planeScene, planeCamera);
      handRenderer.render(handScene, handCamera);
    }

    animate();
  </script>
</body>
</html>
